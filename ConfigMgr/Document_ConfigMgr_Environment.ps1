# ConfigMgr Environment Documentation Script
# Purpose: Generates comprehensive documentation of ConfigMgr environment in Word format
# Requirements: 
#   - PowerShell 5.1 or later
#   - ConfigMgr Console installed
#   - ConfigMgr PowerShell module
#   - Microsoft Word installed
#   - Run with appropriate permissions to query ConfigMgr

# Parameters
param (
    [Parameter(Mandatory = $false)]
    [string]$SiteCode = "AUTO", # Will auto-detect if not provided
    
    [Parameter(Mandatory = $false)]
    [string]$SiteServer = "AUTO", # Will auto-detect if not provided
    
    [Parameter(Mandatory = $false)]
    [string]$OutputPath = "$($env:USERPROFILE)\Documents\ConfigMgr_Documentation_$(Get-Date -Format 'yyyyMMdd_HHmmss').docx"
)

#region Functions

function Write-Log {
    param (
        [string]$Message,
        [string]$Level = "INFO"
    )
    
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    Write-Host "[$timestamp] [$Level] $Message"
}

function Initialize-ConfigMgrConnection {
    Write-Log "Initializing ConfigMgr connection..."
    
    try {
        # Auto-detect site code and server if not provided
        if ($SiteCode -eq "AUTO" -or $SiteServer -eq "AUTO") {
            $SMSProvider = Get-WmiObject -Namespace "root\SMS" -Class SMS_ProviderLocation -ErrorAction Stop
            
            if ($SMSProvider) {
                if ($SiteCode -eq "AUTO") { 
                    $script:SiteCode = $SMSProvider.SiteCode 
                    Write-Log "Auto-detected Site Code: $SiteCode" 
                }
                
                if ($SiteServer -eq "AUTO") { 
                    $script:SiteServer = $SMSProvider.Machine 
                    Write-Log "Auto-detected Site Server: $SiteServer" 
                }
            }
            else {
                throw "Failed to auto-detect Site Code and Site Server"
            }
        }
        
        # Import ConfigMgr module
        if (-not (Get-Module ConfigurationManager)) {
            Import-Module (Join-Path $(Split-Path $ENV:SMS_ADMIN_UI_PATH) ConfigurationManager.psd1) -ErrorAction Stop
            Write-Log "ConfigMgr PowerShell module imported successfully"
        }
        
        # Connect to site
        if (-not (Get-PSDrive -Name $SiteCode -PSProvider CMSite -ErrorAction SilentlyContinue)) {
            New-PSDrive -Name $SiteCode -PSProvider CMSite -Root $SiteServer -ErrorAction Stop | Out-Null
            Write-Log "Connected to ConfigMgr site $SiteCode"
        }
        
        # Set current location to the site drive
        Set-Location "$($SiteCode):" -ErrorAction Stop
        Write-Log "Current location set to $($SiteCode):"
        return $true
    }
    catch {
        Write-Log "Error initializing ConfigMgr connection: $_" -Level "ERROR"
        return $false
    }
}

function Initialize-WordDocument {
    Write-Log "Initializing Word document..."
    
    try {
        $word = New-Object -ComObject Word.Application
        $word.Visible = $false
        
        $doc = $word.Documents.Add()
        
        # Set up document properties
        $doc.PageSetup.Orientation = 1 # wdOrientPortrait
        $doc.PageSetup.TopMargin = 72 # 1 inch in points
        $doc.PageSetup.BottomMargin = 72
        $doc.PageSetup.LeftMargin = 72
        $doc.PageSetup.RightMargin = 72
        
        # Add title page
        $selection = $word.Selection
        
        # Title
        $selection.Font.Size = 24
        $selection.Font.Bold = $true
        $selection.ParagraphFormat.Alignment = 1 # wdAlignParagraphCenter
        $selection.TypeText("Configuration Manager Environment Documentation")
        $selection.TypeParagraph()
        $selection.TypeParagraph()
        
        # Company and date
        $selection.Font.Size = 14
        $selection.Font.Bold = $false
        $selection.TypeText("Site Code: $SiteCode")
        $selection.TypeParagraph()
        $selection.TypeText("Generated: $(Get-Date -Format 'MMMM dd, yyyy HH:mm')")
        $selection.TypeParagraph()
        $selection.TypeText("Generated by: $env:USERNAME")
        $selection.TypeParagraph()
        $selection.TypeParagraph()
        
        # Add table of contents
        $selection.InsertBreak(2) # wdPageBreak
        $selection.Font.Size = 16
        $selection.Font.Bold = $true
        $selection.ParagraphFormat.Alignment = 0 # wdAlignParagraphLeft
        $selection.TypeText("Table of Contents")
        $selection.TypeParagraph()
        $selection.TypeParagraph()
        
        $toc = $doc.TablesOfContents.Add($selection.Range)
        $toc.UseHeadingStyles = $true
        $toc.UseHyperlinks = $true
        $toc.LowerHeadingLevel = 3
        $toc.UpperHeadingLevel = 1
        $toc.TableID = "TableOfContents"
        
        # Add page break
        $selection.InsertBreak(2) # wdPageBreak
        
        return @{
            Word = $word
            Document = $doc
            Selection = $selection
        }
    }
    catch {
        Write-Log "Error creating Word document: $_" -Level "ERROR"
        return $null
    }
}

function Add-Heading {
    param (
        $Selection,
        [string]$Text,
        [int]$Level = 1
    )
    
    # Apply heading style
    $Selection.Style = "Heading $Level"
    $Selection.TypeText($Text)
    $Selection.TypeParagraph()
}

function Add-Paragraph {
    param (
        $Selection,
        [string]$Text
    )
    
    $Selection.Style = "Normal"
    $Selection.TypeText($Text)
    $Selection.TypeParagraph()
}

function Add-Table {
    param (
        $Selection,
        $Data,
        [string[]]$Columns,
        [string]$TableStyle = "Grid Table 4 - Accent 1"
    )
    
    if ($Data -eq $null -or $Data.Count -eq 0) {
        Add-Paragraph -Selection $Selection -Text "No data available."
        return
    }
    
    # Get number of rows and columns
    $rowCount = $Data.Count + 1 # +1 for header row
    $columnCount = $Columns.Count
    
    # Create table
    $table = $Selection.Tables.Add($Selection.Range, $rowCount, $columnCount)
    $table.Style = $TableStyle
    $table.AllowAutoFit = $true
    
    # Add headers
    for ($i = 0; $i -lt $columnCount; $i++) {
        $table.Cell(1, $i + 1).Range.Text = $Columns[$i]
        $table.Cell(1, $i + 1).Range.Bold = $true
    }
    
    # Add data rows
    $rowIndex = 2
    foreach ($row in $Data) {
        for ($i = 0; $i -lt $columnCount; $i++) {
            $columnName = $Columns[$i]
            $cellValue = $row.$columnName
            
            if ($null -eq $cellValue) {
                $cellValue = ""
            }
            elseif ($cellValue -is [DateTime]) {
                $cellValue = $cellValue.ToString("yyyy-MM-dd HH:mm:ss")
            }
            elseif ($cellValue -is [bool]) {
                $cellValue = if ($cellValue) { "Yes" } else { "No" }
            }
            elseif ($cellValue -is [array]) {
                $cellValue = ($cellValue -join ", ")
            }
            
            $table.Cell($rowIndex, $i + 1).Range.Text = $cellValue
        }
        $rowIndex++
    }
    
    # Auto-fit table to contents
    $table.AutoFitBehavior(1) # wdAutoFitContent
    
    # Add space after table
    $Selection.TypeParagraph()
}

function Get-ServerInfo {
    Write-Log "Gathering server information..."
    
    try {
        # Get site system roles
        $siteRoles = Get-CMSiteRole -SiteCode $SiteCode
        
        $serverInfo = @()
        $uniqueServers = $siteRoles | Select-Object -ExpandProperty NetworkOSPath -Unique
        
        foreach ($server in $uniqueServers) {
            $serverName = $server.Replace("\\", "")
            Write-Log "Processing server: $serverName"
            
            # Get roles
            $roles = $siteRoles | Where-Object { $_.NetworkOSPath -eq $server } | ForEach-Object {
                switch ($_.RoleName) {
                    "SMS Application Web Service Point" { "Application Web Service Point" }
                    "SMS Component Server" { "Component Server" }
                    "SMS Distribution Point" { "Distribution Point" }
                    "SMS Management Point" { "Management Point" }
                    "SMS Software Update Point" { "Software Update Point" }
                    "SMS Provider" { "SMS Provider" }
                    "SMS Site Server" { "Site Server" }
                    "SMS Site System" { "Site System" }
                    "SMS State Migration Point" { "State Migration Point" }
                    "SMS SRS Reporting Point" { "Reporting Point" }
                    default { $_.RoleName }
                }
            } | Sort-Object

            # Try to get server health status
            $healthStatus = "Unknown"
            $osVersion = "Unknown"
            $lastBoot = "Unknown"
            
            try {
                $wmiOS = Get-WmiObject -ComputerName $serverName -Class Win32_OperatingSystem -ErrorAction SilentlyContinue
                if ($wmiOS) {
                    $healthStatus = "Online"
                    $osVersion = "$($wmiOS.Caption) (Build $($wmiOS.BuildNumber))"
                    $lastBoot = [Management.ManagementDateTimeConverter]::ToDateTime($wmiOS.LastBootUpTime)
                }
                else {
                    $healthStatus = "Offline or WMI Error"
                }
            }
            catch {
                $healthStatus = "Offline or Access Denied"
            }
            
            # Add to server info collection
            $serverInfo += [PSCustomObject]@{
                ServerName = $serverName
                Roles = ($roles -join ", ")
                HealthStatus = $healthStatus
                OSVersion = $osVersion
                LastBootTime = $lastBoot
            }
        }
        
        return $serverInfo | Sort-Object -Property ServerName
    }
    catch {
        Write-Log "Error gathering server information: $_" -Level "ERROR"
        return @()
    }
}

function Get-PackageInfo {
    Write-Log "Gathering package information..."
    
    try {
        $packages = Get-CMPackage | Select-Object Name, PackageID, Description, 
            @{Name="Size (MB)"; Expression={[math]::Round($_.PackageSize / 1MB, 2)}}, 
            Version, Manufacturer, 
            @{Name="Created"; Expression={$_.SourceDate}},
            @{Name="Last Updated"; Expression={$_.LastRefreshTime}}
        
        return $packages | Sort-Object -Property Name
    }
    catch {
        Write-Log "Error gathering package information: $_" -Level "ERROR"
        return @()
    }
}

function Get-ApplicationInfo {
    Write-Log "Gathering application information..."
    
    try {
        $applications = Get-CMApplication | Select-Object LocalizedDisplayName, 
            @{Name="ApplicationID"; Expression={$_.CI_ID}}, 
            @{Name="Created"; Expression={$_.DateCreated}}, 
            @{Name="LastModified"; Expression={$_.DateLastModified}}, 
            @{Name="Owner"; Expression={$_.Owner}},
            @{Name="Featured"; Expression={$_.Featured}},
            @{Name="Version"; Expression={$_.SoftwareVersion}}
        
        return $applications | Sort-Object -Property LocalizedDisplayName
    }
    catch {
        Write-Log "Error gathering application information: $_" -Level "ERROR"
        return @()
    }
}

function Get-TaskSequenceInfo {
    Write-Log "Gathering task sequence information..."
    
    try {
        $taskSequences = Get-CMTaskSequence | Select-Object Name, PackageID, 
            @{Name="Version"; Expression={$_.Version}}, 
            @{Name="Enabled"; Expression={$_.Enabled}}, 
            @{Name="Last Modified"; Expression={$_.LastModifiedDate}}, 
            @{Name="Boot Image"; Expression={$_.BootImageID}}, 
            @{Name="Category"; Expression={$_.Category}}
        
        return $taskSequences | Sort-Object -Property Name
    }
    catch {
        Write-Log "Error gathering task sequence information: $_" -Level "ERROR"
        return @()
    }
}

function Get-CompliancePolicyInfo {
    Write-Log "Gathering compliance policy information..."
    
    try {
        $compliancePolicies = Get-CMConfigurationPolicy | Where-Object { $_.CategoryInstance_UniqueIDs -like "*SmsConfigurationPolicyCategory*" } | 
            Select-Object LocalizedDisplayName, 
            @{Name="CreatedBy"; Expression={$_.CreatedBy}}, 
            @{Name="DateCreated"; Expression={$_.DateCreated}}, 
            @{Name="DateLastModified"; Expression={$_.DateLastModified}}, 
            @{Name="LastModifiedBy"; Expression={$_.LastModifiedBy}}, 
            @{Name="Enabled"; Expression={$_.Enabled}}, 
            @{Name="Description"; Expression={$_.LocalizedDescription}}
        
        return $compliancePolicies | Sort-Object -Property LocalizedDisplayName
    }
    catch {
        Write-Log "Error gathering compliance policy information: $_" -Level "ERROR"
        return @()
    }
}

function Get-SiteInfo {
    Write-Log "Gathering site information..."
    
    try {
        $siteInfo = Get-CMSite | Select-Object SiteCode, 
            ServerName, 
            Version, 
            InstallDir, 
            @{Name="Status"; Expression={$_.Status}}, 
            Type, 
            @{Name="Mode"; Expression={$_.Mode}}
        
        return $siteInfo
    }
    catch {
        Write-Log "Error gathering site information: $_" -Level "ERROR"
        return @()
    }
}

function Get-BoundaryInfo {
    Write-Log "Gathering boundary information..."
    
    try {
        $boundaries = Get-CMBoundary | Select-Object DisplayName, 
            BoundaryID, 
            @{Name="Type"; Expression={
                switch ($_.BoundaryType) {
                    0 { "IP Subnet" }
                    1 { "Active Directory Site" }
                    2 { "IPv6 Prefix" }
                    3 { "IP Range" }
                    default { "Unknown" }
                }
            }}, 
            Value
        
        return $boundaries | Sort-Object -Property DisplayName
    }
    catch {
        Write-Log "Error gathering boundary information: $_" -Level "ERROR"
        return @()
    }
}

function Get-BoundaryGroupInfo {
    Write-Log "Gathering boundary group information..."
    
    try {
        $boundaryGroups = Get-CMBoundaryGroup | Select-Object Name, 
            GroupID, 
            Description, 
            @{Name="MemberCount"; Expression={$_.MemberCount}}
        
        return $boundaryGroups | Sort-Object -Property Name
    }
    catch {
        Write-Log "Error gathering boundary group information: $_" -Level "ERROR"
        return @()
    }
}

function Get-CollectionInfo {
    param (
        [string]$CollectionType = "Device"
    )
    
    Write-Log "Gathering $CollectionType collection information..."
    
    try {
        $typeID = if ($CollectionType -eq "Device") { 2 } else { 1 }
        
        $collections = Get-CMCollection -CollectionType $typeID | Select-Object Name, 
            CollectionID, 
            MemberCount, 
            @{Name="LimitToCollectionName"; Expression={
                if ($_.LimitToCollectionID) {
                    $limitColl = Get-CMCollection -CollectionId $_.LimitToCollectionID -ErrorAction SilentlyContinue
                    if ($limitColl) { $limitColl.Name } else { $_.LimitToCollectionID }
                } else { "None" }
            }}, 
            @{Name="RefreshType"; Expression={
                switch ($_.RefreshType) {
                    1 { "Manual" }
                    2 { "Periodic" }
                    4 { "Incremental" }
                    6 { "Periodic and Incremental" }
                    default { "Unknown" }
                }
            }}, 
            @{Name="LastRefreshTime"; Expression={$_.LastRefreshTime}}
        
        return $collections | Sort-Object -Property Name
    }
    catch {
        Write-Log "Error gathering $CollectionType collection information: $_" -Level "ERROR"
        return @()
    }
}

function Get-MaintenanceWindowInfo {
    Write-Log "Gathering maintenance window information..."
    
    try {
        $collections = Get-CMDeviceCollection
        $mwInfo = @()
        
        foreach ($collection in $collections) {
            $maintenanceWindows = Get-CMMaintenanceWindow -CollectionId $collection.CollectionID
            
            if ($maintenanceWindows) {
                foreach ($mw in $maintenanceWindows) {
                    $mwInfo += [PSCustomObject]@{
                        CollectionName = $collection.Name
                        WindowName = $mw.Name
                        Description = $mw.Description
                        StartTime = $mw.StartTime
                        Duration = "$($mw.Duration) minutes"
                        IsEnabled = $mw.IsEnabled
                        ApplyToTaskSequence = $mw.ApplyToTaskSequence
                        ApplyToSoftwareUpdates = $mw.ApplyToSoftwareUpdates
                    }
                }
            }
        }
        
        return $mwInfo | Sort-Object -Property CollectionName, WindowName
    }
    catch {
        Write-Log "Error gathering maintenance window information: $_" -Level "ERROR"
        return @()
    }
}

function Get-UpdatesInfo {
    Write-Log "Gathering software updates information..."
    
    try {
        $updateGroups = Get-CMSoftwareUpdateGroup | Select-Object LocalizedDisplayName, 
            CI_ID, 
            DateCreated, 
            DateLastModified, 
            IsDeployed, 
            IsExpired, 
            NumMembers, 
            NumMissing, 
            PercentCompliant
        
        return $updateGroups | Sort-Object -Property LocalizedDisplayName
    }
    catch {
        Write-Log "Error gathering software updates information: $_" -Level "ERROR"
        return @()
    }
}

#endregion Functions

#region Main Script

# Start time for execution tracking
$scriptStartTime = Get-Date
Write-Log "Script started at $scriptStartTime"

# Initialize ConfigMgr connection
if (-not (Initialize-ConfigMgrConnection)) {
    Write-Log "Failed to initialize ConfigMgr connection. Exiting script." -Level "ERROR"
    exit 1
}

# Initialize Word document
$wordObjects = Initialize-WordDocument
if (-not $wordObjects) {
    Write-Log "Failed to initialize Word document. Exiting script." -Level "ERROR"
    exit 1
}

$word = $wordObjects.Word
$doc = $wordObjects.Document
$selection = $wordObjects.Selection

try {
    #region Document Site Information
    Add-Heading -Selection $selection -Text "1. Site Information" -Level 1
    Add-Paragraph -Selection $selection -Text "This section contains information about the ConfigMgr site and its configuration."

    # Site details
    Add-Heading -Selection $selection -Text "1.1 Site Details" -Level 2
    $siteInfo = Get-SiteInfo
    Add-Table -Selection $selection -Data $siteInfo -Columns @("SiteCode", "ServerName", "Version", "InstallDir", "Status", "Type", "Mode")

    # Boundaries
    Add-Heading -Selection $selection -Text "1.2 Boundaries" -Level 2
    $boundaries = Get-BoundaryInfo
    Add-Table -Selection $selection -Data $boundaries -Columns @("DisplayName", "BoundaryID", "Type", "Value")

    # Boundary Groups
    Add-Heading -Selection $selection -Text "1.3 Boundary Groups" -Level 2
    $boundaryGroups = Get-BoundaryGroupInfo
    Add-Table -Selection $selection -Data $boundaryGroups -Columns @("Name", "GroupID", "Description", "MemberCount")
    #endregion

    #region Document Servers and Roles
    Add-Heading -Selection $selection -Text "2. Servers and Roles" -Level 1
    Add-Paragraph -Selection $selection -Text "This section provides information about all servers in the ConfigMgr environment, including their roles and health status."

    $servers = Get-ServerInfo
    Add-Table -Selection $selection -Data $servers -Columns @("ServerName", "Roles", "HealthStatus", "OSVersion", "LastBootTime")
    #endregion

    #region Document Packages
    Add-Heading -Selection $selection -Text "3. Packages" -Level 1
    Add-Paragraph -Selection $selection -Text "This section lists all packages configured in the ConfigMgr environment."

    $packages = Get-PackageInfo
    Add-Table -Selection $selection -Data $packages -Columns @("Name", "PackageID", "Description", "Size (MB)", "Version", "Manufacturer", "Created", "Last Updated")
    #endregion

    #region Document Applications
    Add-Heading -Selection $selection -Text "4. Applications" -Level 1
    Add-Paragraph -Selection $selection -Text "This section lists all applications configured in the ConfigMgr environment."

    $applications = Get-ApplicationInfo
    Add-Table -Selection $selection -Data $applications -Columns @("LocalizedDisplayName", "ApplicationID", "Version", "Owner", "Created", "LastModified", "Featured")
    #endregion

    #region Document Task Sequences
    Add-Heading -Selection $selection -Text "5. Task Sequences" -Level 1
    Add-Paragraph -Selection $selection -Text "This section lists all task sequences configured in the ConfigMgr environment."

    $taskSequences = Get-TaskSequenceInfo
    Add-Table -Selection $selection -Data $taskSequences -Columns @("Name", "PackageID", "Version", "Enabled", "Last Modified", "Boot Image", "Category")
    #endregion

    #region Document Compliance Policies
    Add-Heading -Selection $selection -Text "6. Compliance Policies" -Level 1
    Add-Paragraph -Selection $selection -Text "This section lists all compliance policies configured in the ConfigMgr environment."

    $compliancePolicies = Get-CompliancePolicyInfo
    Add-Table -Selection $selection -Data $compliancePolicies -Columns @("LocalizedDisplayName", "Enabled", "Description", "CreatedBy", "DateCreated", "LastModifiedBy", "DateLastModified")
    #endregion

    #region Document Collections
    Add-Heading -Selection $selection -Text "7. Collections" -Level 1
    Add-Paragraph -Selection $selection -Text "This section lists all device and user collections configured in the ConfigMgr environment."

    # Device Collections
    Add-Heading -Selection $selection -Text "7.1 Device Collections" -Level 2
    $deviceCollections = Get-CollectionInfo -CollectionType "Device"
    Add-Table -Selection $selection -Data $deviceCollections -Columns @("Name", "CollectionID", "MemberCount", "LimitToCollectionName", "RefreshType", "LastRefreshTime")

    # User Collections
    Add-Heading -Selection $selection -Text "7.2 User Collections" -Level 2
    $userCollections = Get-CollectionInfo -CollectionType "User"
    Add-Table -Selection $selection -Data $userCollections -Columns @("Name", "CollectionID", "MemberCount", "LimitToCollectionName", "RefreshType", "LastRefreshTime")
    #endregion

    #region Document Maintenance Windows
    Add-Heading -Selection $selection -Text "8. Maintenance Windows" -Level 1
    Add-Paragraph -Selection $selection -Text "This section lists all maintenance windows configured for collections in the ConfigMgr environment."

    $maintenanceWindows = Get-MaintenanceWindowInfo
    Add-Table -Selection $selection -Data $maintenanceWindows -Columns @("CollectionName", "WindowName", "Description", "StartTime", "Duration", "IsEnabled", "ApplyToTaskSequence", "ApplyToSoftwareUpdates")
    #endregion

    #region Document Software Update Groups
    Add-Heading -Selection $selection -Text "9. Software Update Groups" -Level 1
    Add-Paragraph -Selection $selection -Text "This section lists all software update groups configured in the ConfigMgr environment."

    $updateGroups = Get-UpdatesInfo
    Add-Table -Selection $selection -Data $updateGroups -Columns @("LocalizedDisplayName", "CI_ID", "NumMembers", "IsDeployed", "IsExpired", "PercentCompliant", "DateCreated", "DateLastModified")
    #endregion

    # Update Table of Contents
    $selection.GoTo(1) # wdGoToBookmark
    $doc.TablesOfContents(1).Update()

    # Save the document
    Write-Log "Saving document to $OutputPath..."
    $doc.SaveAs([ref]$OutputPath)
    Write-Log "Document saved successfully!"

    # Open the document
    $word.Visible = $true
}
catch {
    Write-Log "Error generating documentation: $_" -Level "ERROR"
}
finally {
    # Disconnect from ConfigMgr
    Set-Location $env:SystemDrive
    Write-Log "Disconnected from ConfigMgr site"
    
    $scriptEndTime = Get-Date
    $executionTime = $scriptEndTime - $scriptStartTime
    Write-Log "Script completed in $($executionTime.TotalMinutes.ToString('0.00')) minutes"
}

#endregion Main Script